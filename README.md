# Лабораторная работа 1. Алгоритмы поиска в матрице.

## 1. Выбор языка программирования

Работа была выполнена на языке программирования Java.

## 2. Код

### 2.1 Класс Matrix

Для генерации матриц и тестирования алгоритмов был создан класс Matrix:

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/f687fd99-0352-432d-97b3-5fefd028ed0d)


### 2.2 Генерация матриц

Первый способ:

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/88fea238-3b6a-4db2-8d70-33f907b493f9)

Второй способ:

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/c52241c3-e731-4c42-9dfb-b8bf035601d3)

### 2.3 Binary search

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/ce30ec49-2d9c-40ae-a91d-8db762046519)

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/472d69cc-0f54-40de-8b1f-62f66b0558dd)

### 2.4 Ladder search

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/5e8db3e5-61d2-4519-a148-632a74e010f9)

### 2.5 Exponentional search

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/88cc37f7-798e-4951-8d35-643d88dd93b5)

## 3. Визуализация

### 3.1 Таблица с результатами работы алгоритмов на первом способе генерации матриц

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/d65811dc-33e7-4a16-a6d1-6d7c5911cab7)

### 3.2 График по таблице 1

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/f5b0c3b5-6754-47cd-b370-1ca769807817)

### 3.3 Таблица с результатами работы алгоритмов на втором способе генерации матриц

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/f3c91654-a09c-497f-bc30-288fcb0f3ed1)

### 3.4 График по таблице 2

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/07295eca-2cdb-4da7-a728-0641235d36d7)

## 3.5 Отношение времени работы на первом типе генерации матриц ко времени работы на втором типе генерации матриц

![image](https://github.com/luvdoomed/algorithms-lab1/assets/124821375/5b65ce2b-4161-408a-bbad-4ea8716cb01a)

## 4. Сравнение алгоритмов

### 4.1. На первом типе генерации данных:
Бинарный поиск работает практически одинаково по скорости с экспоненциальным на небольшом количестве строк **(до 128)**, опережая в скорости поиск лесенкой.

При размере матрицы **128 x 8192** время работы поиска "Лесенкой" становится равным времени работы бинарного и экспоненциального поисков.

Начиная с размера матрицы **256 x 8192**, разница становится все более заметной, с увеличением строк бинарный поиск работает все хуже в сравнении с двумя другими алгоритмами. Поиск "Лесенкой" остается быстрее экспоненциального.

При достижении максимального размера матрицы **8192 x 8192** бинарный поиск в разы медленнее поиска "Лесенкой" и экспоненциального поиска.

### 4.2. На втором типе генерации данных:

Бинарный поиск работает медленнее экспоненциального на любом размере матрицы.

При размере матрицы **256 x 8192** время работы поиска "Лесенкой" становится меньше времени работы бинарного и экспоненциального поисков.

При достижении максимального размера матрицы **8192 x 8192** бинарный поиск в разы медленнее поиска "Лесенкой" и экспоненциального поиска.

Экспоненциальный поиск работает быстрее поиска "Лесенкой" на любом размере матрицы.

## 5. Вывод

5.1. Были написаны три алгоритма на Java, выведены данные измерений в Excel файл и создана их визуализация с помощью графиков.

5.2. Было приведено сравнение времени работы этих алгоритмов на двух типах генерации данных.

5.3. Бинарный поиск стоит использовать при небольшом количестве строк, т.к при таких данных **M*log(N) < M + N** (например: **256*log(8192) < 256 + 8192**). 

При этом на больших данных эффективен поиск “Лесенкой” (**8192 * log(8912) = 107000** при бинарном поиске, а **8912 + 8192 = 16384** при поиске “Лесенкой”).

Экспоненциальный поиск самый эффективный из трех алгоритмов, т.к. на небольших он работает примерно одинаково с бинарными поиском, а на больших с поиском "Лесенкой".





